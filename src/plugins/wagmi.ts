import type { Output, Plugin } from '../config'
import { camelCase, pascalCase } from 'change-case'
import dedent from 'dedent'

export function wagmi(): Plugin {
  return {
    name: 'wagmi',
    async run(config) {
      const imports = [
        '/* Autogenerated file. Do not edit manually. */',
        '/* tslint:disable */',
        '/* eslint-disable */',
        dedent`
          import {
            createWatchContractEvent,
            createWatchContractEventBy,
            createGetContract,
            createGetContractBy,
            createReadContract,
            createReadContractBy,
            createWriteContract,
            createWriteContractBy,
            createSimulateContract,
            createSimulateContractBy,
            createUseContract,
            createUseContractBy,
          } from './library'

          import {
            createUseReadContract,
            createUseSimulateContract,
            createUseWatchContractEvent,
            createUseWriteContract,
          } from 'wagmi/codegen'
        `,
        `import { ${Object.keys(config.contracts).map(name => `${camelCase(`  ${name}Abi`)}`).join(', ')}, addresses } from './config'`,
        `export { ${Object.keys(config.contracts).map(name => `${camelCase(`  ${name}Abi`)}`).join(', ')} } from './config'`,
        `export { SubscribeWagmiConfig, type SubscribeWagmiConfigProps } from './library'`,
        dedent`
          export {
            addresses,
            chain,
            chains,
            client,
            wallet,
          } from './config'
        `,
      ]

      const contents: (string | string[])[] = [
        'export const getContract = createGetContract()',
        'export const useContract = createUseContract()',
        '',
        Object.keys(config.contracts).map((name) => {
          const camelCaseName = camelCase(name)
          const pascalCaseName = pascalCase(name)
          const watchItems: string[] = []
          const watchHooks: string[] = []
          const readItems: string[] = []
          const readHooks: string[] = []
          const writeItems: string[] = []
          const writeHooks: string[] = []
          const simulateItems: string[] = []
          const simulateHooks: string[] = []

          const readNames = new Set<string>()
          const writeNames = new Set<string>()
          const watchNames = new Set<string>()

          for (const item of config.contracts[name]) {
            if (item.type === 'function') {
              if (item.stateMutability === 'view' || item.stateMutability === 'pure') {
                if (readNames.has(item.name))
                  continue
                readNames.add(item.name)
                readItems.push(`export const read${pascalCaseName}${pascalCase(item.name)} = createReadContractBy(${camelCaseName}Abi, '${item.name}')`)
                readHooks.push(`export const useRead${pascalCaseName}${pascalCase(item.name)} = createUseReadContract({ abi: ${camelCaseName}Abi, address: ${camelCaseName}Address, functionName: '${item.name}' })`)
              }

              if (item.stateMutability === 'nonpayable' || item.stateMutability === 'payable') {
                if (writeNames.has(item.name))
                  continue
                writeNames.add(item.name)
                writeItems.push(`export const write${pascalCaseName}${pascalCase(item.name)} = createWriteContractBy(${camelCaseName}Abi, '${item.name}')`)
                writeHooks.push(`export const useWrite${pascalCaseName}${pascalCase(item.name)} = createUseWriteContract({ abi: ${camelCaseName}Abi, address: ${camelCaseName}Address, functionName: '${item.name}' })`)
                simulateItems.push(`export const simulate${pascalCaseName}${pascalCase(item.name)} = createSimulateContractBy(${camelCaseName}Abi, '${item.name}')`)
                simulateHooks.push(`export const useSimulate${pascalCaseName}${pascalCase(item.name)} = createUseSimulateContract({ abi: ${camelCaseName}Abi, address: ${camelCaseName}Address, functionName: '${item.name}' })`)
              }
            }
            else if (item.type === 'event') {
              if (watchNames.has(item.name))
                continue
              watchNames.add(item.name)
              watchItems.push(`export const watch${pascalCaseName}${pascalCase(item.name)}Event = createWatchContractEventBy(${camelCaseName}Abi, '${item.name}')`)
            }
          }
          return [
            `export const get${pascalCaseName} = createGetContractBy(${camelCaseName}Abi)`,
            `export const use${pascalCaseName} = createUseContractBy(${camelCaseName}Abi)`,
            `export const ${camelCaseName}Address = Reflect.get(addresses, '${name}')`,
            '',
            `export const watch${pascalCaseName}Event = createWatchContractEvent(${camelCaseName}Abi)`,
            ...watchItems,

            `export const useWatch${pascalCaseName}Event = createUseWatchContractEvent({ abi: ${camelCaseName}Abi, address: ${camelCaseName}Address })`,
            ...watchHooks,
            '',
            `export const read${pascalCaseName} = createReadContract(${camelCaseName}Abi)`,
            ...readItems,
            '',
            `export const useRead${pascalCaseName} = createUseReadContract({ abi: ${camelCaseName}Abi, address: ${camelCaseName}Address })`,
            ...readHooks,
            '',
            `export const write${pascalCaseName} = createWriteContract(${camelCaseName}Abi)`,
            ...writeItems,
            '',
            `export const useWrite${pascalCaseName} = createUseWriteContract({ abi: ${camelCaseName}Abi, address: ${camelCaseName}Address })`,
            ...writeHooks,
            '',
            `export const simulate${pascalCaseName} = createSimulateContract(${camelCaseName}Abi)`,
            ...simulateItems,
            '',
            `export const useSimulate${pascalCaseName} = createUseSimulateContract({ abi: ${camelCaseName}Abi, address: ${camelCaseName}Address })`,
            ...simulateHooks,
          ].join('\n')
        }).join('\n\n'),
      ]

      const outputs: Output[] = [
        ...await outputUtils(),
        ...await outputLibrary(),
        {
          id: 'config.ts',
          content: dedent`
            /* Autogenerated file. Do not edit manually. */
            /* tslint:disable */
            /* eslint-disable */
            import type { Account, Chain, PublicClient, Transport, WalletClient } from "viem"
            import { proxy, set } from "./utils"

            export const client = proxy<PublicClient>('client')
            export const wallet = proxy<WalletClient<Transport, Chain, Account>>('wallet')
            export const chain = proxy<typeof chains[keyof typeof chains]>('chain')

            export const chains = ${JSON.stringify(config.chains)} as const

            export const addresses = ${JSON.stringify(config.addresses)} as const

            ${Object
              .keys(config.contracts)
              .map(name => `export const ${camelCase(`${name}Abi`)} = set(${JSON.stringify(config.contracts[name])} as const, 'name', '${name}')`)
              .join('\n\n')}
          `,
        },
        {
          id: 'index.ts',
          imports: imports.join('\n'),
          content: contents.flat().join('\n'),
        },
      ]

      return outputs
    },
  }
}

async function outputUtils(): Promise<Output[]> {
  return [{
    id: 'utils.ts',
    content: dedent`
    /* Autogenerated file. Do not edit manually. */
    /* tslint:disable */
    /* eslint-disable */
    export type Proxyed<T extends object> = T & { proxy: { update: (object?: T) => void, resolve: () => T | undefined } }

    export function proxy<T extends object>(name: string, initObject?: T): Proxyed<T> {
      initObject && Reflect.set(initObject, 'proxyUpdated', true)
      let target: any = initObject || { proxyUpdated: false }
      const proxy = new Proxy({} as T, {
        get: (_, p) => {
          if (p === 'proxy') return { update, resolve }
          if (!Reflect.get(target, 'proxyUpdated'))
            throw new Error(\`Proxy not updated. Call \${name}.update() to update the proxy.\`)
          return typeof target?.[p] === 'function' ? target?.[p].bind(target) : target?.[p]
        },
        set: (_, p, v) => { target[p] = v; return true },
      })
      function update(object?: T): void {
        if (object) { Reflect.set(object, 'proxyUpdated', true); target = object }
        else { target = undefined }
      }
      function resolve(): T | undefined {
        return Reflect.get(target, 'proxyUpdated') ? target : undefined
      }
      return proxy as Proxyed<T>
    }

    export function get(target: any, keys: string): any {
      return keys.split('.').reduce((acc, key) => acc?.[key], target)
    }

    export function set<T extends object>(target: T, property: string, value: any): T {
      Reflect.set(target, property, value)
      return target as T
    }
    `,
  }] as Output[]
}

async function outputLibrary(): Promise<Output[]> {
  return [{
    id: 'library.ts',
    content: dedent`
      /* Autogenerated file. Do not edit manually. */
      /* tslint:disable */
      /* eslint-disable */
      import type {
        Abi,
        Account,
        Address,
        Chain,
        Client,
        ContractEventName,
        ContractFunctionArgs,
        ContractFunctionName,
        GetContractParameters,
        SimulateContractParameters,
        ReadContractParameters,
        Transport,
        WalletClient,
        WatchContractEventParameters,
        WriteContractParameters
      } from "viem"
      import { createPublicClient, createWalletClient, custom, getContract, http } from 'viem'
      import { useEffect, useMemo } from 'react'
      import type { ReactNode } from 'react'
      import { usePublicClient, useWalletClient, useChainId, useAccount } from 'wagmi'
      import { readContract, watchContractEvent, writeContract, simulateContract } from "viem/actions"
      import { get } from "./utils";
      import { addresses, chain, chains, client, wallet } from "./config";

      export interface SubscribeWagmiConfigProps {
        forceLockChain?: typeof chains[keyof typeof chains]['id']
        children?: ReactNode
      }
      export type KeyedClient<
        transport extends Transport = Transport,
        chain extends Chain | undefined = Chain | undefined,
        account extends Account | undefined = Account | undefined,
      > =
        | { public?: Client<transport, chain> | undefined; wallet: Client<transport, chain, account> }
        | { public: Client<transport, chain>; wallet?: Client<transport, chain, account> | undefined }
      export type PartialPick<T, K extends keyof T> = { [P in K]?: T[P] } & Omit<T, K>


      export function createWatchContractEvent<
        chain extends Chain | undefined,
        const abi extends Abi | readonly unknown[],

        strict extends boolean | undefined = undefined,
        transport extends Transport = Transport,
      >(abi: abi) {
        type parameters<
          eventName extends ContractEventName<abi> | undefined = undefined,
        > = WatchContractEventParameters<abi, eventName, strict, transport>
        type client = Client<transport, chain>
        return <
          eventName extends ContractEventName<abi> | undefined = undefined
        >(parameters: Omit<parameters<eventName>, 'abi'> & { client?: client }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return watchContractEvent((parameters.client || client) as client, { abi, address, ...parameters } as parameters)
        }
      }

      export function createWatchContractEventBy<
        chain extends Chain | undefined,
        const abi extends Abi | readonly unknown[],
        eventName extends ContractEventName<abi> | undefined = undefined,
        strict extends boolean | undefined = undefined,
        transport extends Transport = Transport,
      >(abi: abi, eventName: eventName) {
        type parameters = WatchContractEventParameters<abi, eventName, strict, transport>
        type client = Client<transport, chain>
        return (parameters: Omit<parameters, 'abi'> & { client?: client }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return watchContractEvent((parameters.client || client) as client, { abi, address, ...parameters } as parameters)
        }
      }

      export function createReadContract<
        chain extends Chain | undefined,
        const abi extends Abi | readonly unknown[],
        transport extends Transport = Transport,
      >(abi: abi) {
        type client = Client<transport, chain>
        return <
          functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
          const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
        >(parameters: Omit<ReadContractParameters<abi, functionName, args>, 'abi'> & { client?: client }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return readContract((parameters.client || client) as client, { abi, address, ...parameters } as ReadContractParameters<abi, functionName, args>)
        }
      }

      export function createReadContractBy<
        chain extends Chain | undefined,
        const abi extends Abi | readonly unknown[],
        functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
        transport extends Transport = Transport,
      >(abi: abi, functionName: functionName) {
        type client = Client<transport, chain>

        return <
          const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
        >(parameters: Omit<ReadContractParameters<abi, functionName, args>, 'abi' | 'functionName'>  & { client?: client }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return readContract((parameters.client || client) as client, { abi, address, functionName, ...parameters } as ReadContractParameters<abi, functionName, args>)
        }
      }


      export function createWriteContract<
        chain extends Chain | undefined,
        account extends Account | undefined,
        const abi extends Abi | readonly unknown[],
        chainOverride extends Chain | undefined,
      >(abi: abi) {
        type parameters<
          functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        > = WriteContractParameters<abi, functionName, args, chain, account, chainOverride>
        type wallet = WalletClient<Transport, chain, account>
        return <
          functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        >(parameters: Omit<PartialPick<parameters<functionName, args>, 'chain' | 'account' | 'address'>, 'abi'> & { client?: wallet }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return writeContract((parameters.client || wallet) as wallet, { address, abi, ...parameters } as unknown as parameters<functionName, args>)
        }
      }
      export function createWriteContractBy<
        chain extends Chain | undefined,
        account extends Account | undefined,
        const abi extends Abi | readonly unknown[],
        functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
        chainOverride extends Chain | undefined,
      >(abi: abi, functionName: functionName) {
        type parameters<
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        > = WriteContractParameters<abi, functionName, args, chain, account, chainOverride>
        type wallet = WalletClient<Transport, chain, account>
        return <
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        >(parameters: Omit<PartialPick<parameters<args>, 'chain' | 'account' | 'address'>, 'abi' | 'functionName'>  & { client?: wallet }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return writeContract((parameters.client || wallet) as wallet, { address, abi, functionName, ...parameters } as unknown as parameters<args>)
        }
      }

      export function createSimulateContract<
        chain extends Chain | undefined,
        account extends Account | undefined,
        const abi extends Abi | readonly unknown[]
      >(abi: abi) {
        type parameters<
          functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        > = SimulateContractParameters<abi, functionName, args, chain>
        type wallet = WalletClient<Transport, chain, account>
        return <
          functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        >(parameters: Omit<PartialPick<parameters<functionName, args>, 'chain' | 'account' | 'address'>, 'abi'> & { client?: wallet }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return simulateContract((parameters.client || wallet) as wallet, { address, abi, ...parameters } as unknown as parameters<functionName, args>)
        }
      }

      export function createSimulateContractBy<
        chain extends Chain | undefined,
        account extends Account | undefined,
        const abi extends Abi | readonly unknown[],
        functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>
      >(abi: abi, functionName: functionName) {
        type parameters<
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        > = SimulateContractParameters<abi, functionName, args, chain>
        type wallet = WalletClient<Transport, chain, account>
        return <
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        >(parameters: Omit<PartialPick<parameters<args>, 'chain' | 'account' | 'address'>, 'abi' | 'functionName'> & { client?: wallet }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return simulateContract((parameters.client || wallet) as wallet, { address, abi, functionName, ...parameters } as unknown as parameters<args>)
        }
      }

      export function createGetContract<
        transport extends Transport,
        address extends Address,
        const client extends
        | Client<transport, chain, account>
        | KeyedClient<transport, chain, account>,
        chain extends Chain | undefined = Chain | undefined,
        account extends Account | undefined = Account | undefined,
      >() {
        type parameters<abi extends Abi | readonly unknown[]> = GetContractParameters<transport, chain, account, abi, client, address>
        return <abi extends Abi | readonly unknown[]>(parameters: PartialPick<parameters<abi>, 'client' | 'address'>) => {
          const address = parameters.address || get(chain, \`contracts.\${get(parameters.abi, 'name')}.address\`)
          const clients = (parameters.client || { public: client, wallet: wallet }) as Client<transport, chain, account>
          return getContract({ address, abi: parameters.abi, client: clients })
        }
      }

      export function createGetContractBy<
        transport extends Transport,
        address extends Address,
        const abi extends Abi | readonly unknown[],
        const client extends
        | Client<transport, chain, account>
        | KeyedClient<transport, chain, account>,
        chain extends Chain | undefined = Chain | undefined,
        account extends Account | undefined = Account | undefined,
      >(abi: abi) {
        type parameters = GetContractParameters<transport, chain, account, abi, client, address>
        return (parameters: Partial<Pick<parameters, 'client' | 'address'>>) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          const clients = (parameters.client || { public: client, wallet: wallet }) as Client<transport, chain, account>
          return getContract({ address, abi, client: clients })
        }
      }


      export function createUseContract<
        transport extends Transport,
        address extends Address,
        const client extends
        | Client<transport, chain, account>
        | KeyedClient<transport, chain, account>,
        chain extends Chain | undefined = Chain | undefined,
        account extends Account | undefined = Account | undefined,
      >() {
        type parameters<abi extends Abi | readonly unknown[]> = GetContractParameters<transport, chain, account, abi, client, address>
        return <abi extends Abi | readonly unknown[]>(parameters: PartialPick<parameters<abi>, 'client' | 'address'>) => {
          const address = parameters.address || get(addresses, \`\${get(parameters.abi, 'name')}.\${useChainId()}\`)
          const clients = (parameters.client || { public: usePublicClient(), wallet: useWalletClient() })
          return getContract({ address, abi: parameters.abi, client: clients as Client<transport, chain, account> })
        }
      }

      export function createUseContractBy<
        transport extends Transport,
        address extends Address,
        const abi extends Abi | readonly unknown[],
        const client extends
        | Client<transport, chain, account>
        | KeyedClient<transport, chain, account>,
        chain extends Chain | undefined = Chain | undefined,
        account extends Account | undefined = Account | undefined,
      >(abi: abi) {
        type parameters = GetContractParameters<transport, chain, account, abi, client, address>
        return (parameters: Partial<Pick<parameters, 'client' | 'address'>>) => {
          const address = parameters.address || get(addresses, \`\${get(abi, 'name')}.\${useChainId()}\`)
          const clients = (parameters.client || { public: usePublicClient(), wallet: useWalletClient() })
          return getContract({ address, abi, client: clients as Client<transport, chain, account> })
        }
      }

      export function SubscribeWagmiConfig(props: SubscribeWagmiConfigProps) {
        const chainId = props.forceLockChain ?? useChainId()
        const current = useMemo(() => find(chainId), [chainId])
        const account = useAccount().address

        function find(id: number) {
          return Object.values(chains).find(chain => chain.id === id)
        }

        useEffect(
          () => {
            if (!account)
              return
            const transport = custom(Reflect.get(window, 'ethereum'))
            wallet.proxy.update(createWalletClient({ chain: current!, transport, account }))
          },
          [account, current],
        )
        useEffect(
          () => {
            client.proxy.update(createPublicClient({ chain: current!, transport: http() }))
            chain.proxy.update(current)
          },
          [current]
        )
        return props.children
      }
    `,
  }] as Output[]
}
