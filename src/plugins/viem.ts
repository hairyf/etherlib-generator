import type { Output, Plugin } from '../config'
import { camelCase, pascalCase } from 'change-case'
import dedent from 'dedent'

export function viem(): Plugin {
  return {
    name: 'viem',
    async run(config) {
      const imports = [
        '/* Autogenerated file. Do not edit manually. */',
        '/* tslint:disable */',
        '/* eslint-disable */',
        dedent`
          import {
            createWatchContractEvent,
            createWatchContractEventBy,
            createGetContract,
            createGetContractBy,
            createReadContract,
            createWriteContract,
            createReadContractBy,
            createWriteContractBy,
          } from './library'
        `,
        `import { ${Object.keys(config.contracts).map(name => `${camelCase(`  ${name}Abi`)}`).join(', ')} } from './config'`,
        `export { ${Object.keys(config.contracts).map(name => `${camelCase(`  ${name}Abi`)}`).join(', ')} } from './config'`,
        dedent`
          export {
            addresses,
            chain,
            chains,
            client,
            wallet,
          } from './config'
        `,
      ]

      const contents: (string | string[])[] = [
        'export const getContract = createGetContract()',
        '',
        Object.keys(config.contracts).map((name) => {
          const camelCaseName = camelCase(name)
          const pascalCaseName = pascalCase(name)
          const watchItems: string[] = []
          const readItems: string[] = []
          const writeItems: string[] = []

          const readNames = new Set<string>()
          const writeNames = new Set<string>()
          const watchNames = new Set<string>()
          for (const item of config.contracts[name]) {
            if (item.type === 'function') {
              if (item.stateMutability === 'view' || item.stateMutability === 'pure') {
                if (readNames.has(item.name))
                  continue
                readNames.add(item.name)
                readItems.push(`export const read${pascalCaseName}${pascalCase(item.name)} = createReadContractBy(${camelCaseName}Abi, '${item.name}')`)
              }

              if (item.stateMutability === 'nonpayable' || item.stateMutability === 'payable') {
                if (writeNames.has(item.name))
                  continue
                writeNames.add(item.name)
                writeItems.push(`export const write${pascalCaseName}${pascalCase(item.name)} = createWriteContractBy(${camelCaseName}Abi, '${item.name}')`)
              }
            }
            else if (item.type === 'event') {
              if (watchNames.has(item.name))
                continue
              watchNames.add(item.name)
              watchItems.push(`export const watch${pascalCaseName}${pascalCase(item.name)}Event = createWatchContractEventBy(${camelCaseName}Abi, '${item.name}')`)
            }
          }
          return [
            `export const get${pascalCaseName} = createGetContractBy(${camelCaseName}Abi)`,
            '',
            `export const watch${pascalCaseName}Event = createWatchContractEvent(${camelCaseName}Abi)`,
            ...watchItems,
            '',
            `export const read${pascalCaseName} = createReadContract(${camelCaseName}Abi)`,
            ...readItems,
            '',
            `export const write${pascalCaseName} = createWriteContract(${camelCaseName}Abi)`,
            ...writeItems,
          ].join('\n')
        }).join('\n\n'),
      ]

      const outputs: Output[] = [
        ...await outputUtils(),
        ...await outputLibrary(),
        {
          id: 'config.ts',
          content: dedent`
            /* Autogenerated file. Do not edit manually. */
            /* tslint:disable */
            /* eslint-disable */
            import type { PublicClient, WalletClient } from "viem"
            import { proxy, set } from "./utils"

            export const client = proxy<PublicClient>()
            export const wallet = proxy<WalletClient>()
            export const chain = proxy<typeof chains[keyof typeof chains]>()

            export const chains = ${JSON.stringify(config.chains)} as const

            export const addresses = ${JSON.stringify(config.addresses)} as const

            ${Object
              .keys(config.contracts)
              .map(name => `export const ${camelCase(`${name}Abi`)} = set(${JSON.stringify(config.contracts[name])} as const, 'name', '${name}')`)
              .join('\n\n')}
          `,
        },
        {
          id: 'index.ts',
          imports: imports.join('\n'),
          content: contents.flat().join('\n'),
        },
      ]

      return outputs
    },
  }
}

async function outputUtils(): Promise<Output[]> {
  return [{
    id: 'utils.ts',
    content: dedent`
      /* Autogenerated file. Do not edit manually. */
      /* tslint:disable */
      /* eslint-disable */
      export type Proxyed<T extends object> = T & { proxy: { update: (object?: T) => void, resolve: () => T | undefined } }

      export function proxy<T extends object>(initObject?: T): Proxyed<T> {
        initObject && Reflect.set(initObject, 'proxyUpdated', true)
        let target: any = initObject || { proxyUpdated: false }
        const proxy = new Proxy({} as T, {
          get: (_, p) => typeof target?.[p] === 'function' ? target?.[p].bind(target) : target?.[p],
          set: (_, p, v) => { target[p] = v; return true },
        })
        function update(object?: T): void {
          if (object) { Reflect.set(object, 'proxyUpdated', true); target = object }
          else { target = undefined }
        }
        function resolve(): T | undefined {
          return Reflect.get(target, 'proxyUpdated') ? target : undefined
        }
        Reflect.set(proxy, 'proxy', { update, resolve })
        return proxy as Proxyed<T>
      }

      export function get(target: any, keys: string): any {
        return keys.split('.').reduce((acc, key) => acc?.[key], target)
      }

      export function set<T extends object>(target: T, property: string, value: any): T {
        Reflect.set(target, property, value)
        return target as T
      }
    `,
  }] as Output[]
}

async function outputLibrary(): Promise<Output[]> {
  return [{
    id: 'library.ts',
    content: dedent`
      /* Autogenerated file. Do not edit manually. */
      /* tslint:disable */
      /* eslint-disable */
      import type {
        Abi,
        Account,
        Address,
        Chain,
        Client,
        ContractEventName,
        ContractFunctionArgs,
        ContractFunctionName,
        GetContractParameters,
        PublicClient,
        ReadContractParameters,
        Transport,
        WalletClient,
        WatchContractEventParameters,
        WriteContractParameters
      } from "viem"
      import { getContract } from 'viem'
      import { readContract, watchContractEvent, writeContract } from "viem/actions"
      import { get } from "./utils";
      import { chain, client, wallet } from "./config";

      export type KeyedClient<
        transport extends Transport = Transport,
        chain extends Chain | undefined = Chain | undefined,
        account extends Account | undefined = Account | undefined,
      > =
        | { public?: Client<transport, chain> | undefined; wallet: Client<transport, chain, account> }
        | { public: Client<transport, chain>; wallet?: Client<transport, chain, account> | undefined }
      export type PartialPick<T, K extends keyof T> = { [P in K]?: T[P] } & Omit<T, K>


      export function createWatchContractEvent<
        chain extends Chain | undefined,
        const abi extends Abi | readonly unknown[],

        strict extends boolean | undefined = undefined,
        transport extends Transport = Transport,
      >(abi: abi) {
        type parameters<
          eventName extends ContractEventName<abi> | undefined = undefined,
        > = WatchContractEventParameters<abi, eventName, strict, transport>
        type client = Client<transport, chain>
        return <
          eventName extends ContractEventName<abi> | undefined = undefined
        >(parameters: Omit<parameters<eventName>, 'abi'> & { client?: client }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return watchContractEvent((parameters.client || client) as client, { abi, address, ...parameters } as parameters)
        }
      }

      export function createWatchContractEventBy<
        chain extends Chain | undefined,
        const abi extends Abi | readonly unknown[],
        eventName extends ContractEventName<abi> | undefined = undefined,
        strict extends boolean | undefined = undefined,
        transport extends Transport = Transport,
      >(abi: abi, eventName: eventName) {
        type parameters = WatchContractEventParameters<abi, eventName, strict, transport>
        type client = Client<transport, chain>
        return (parameters: Omit<parameters, 'abi'> & { client?: client }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return watchContractEvent((parameters.client || client) as client, { abi, address, ...parameters } as parameters)
        }
      }

      export function createReadContract<
        chain extends Chain | undefined,
        const abi extends Abi | readonly unknown[],
        transport extends Transport = Transport,
      >(abi: abi) {
        type client = Client<transport, chain>
        return <
          functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
          const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
        >(parameters: Omit<ReadContractParameters<abi, functionName, args>, 'abi'> & { client?: client }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return readContract((parameters.client || client) as client, { abi, address, ...parameters } as ReadContractParameters<abi, functionName, args>)
        }
      }

      export function createReadContractBy<
        chain extends Chain | undefined,
        const abi extends Abi | readonly unknown[],
        functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
        transport extends Transport = Transport,
      >(abi: abi, functionName: functionName) {
        type client = Client<transport, chain>

        return <
          const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
        >(parameters: Omit<ReadContractParameters<abi, functionName, args>, 'abi' | 'functionName'>  & { client?: client }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return readContract((parameters.client || client) as client, { abi, address, functionName, ...parameters } as ReadContractParameters<abi, functionName, args>)
        }
      }


      export function createWriteContract<
        chain extends Chain | undefined,
        account extends Account | undefined,
        const abi extends Abi | readonly unknown[],
        chainOverride extends Chain | undefined,
      >(abi: abi) {
        type parameters<
          functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        > = WriteContractParameters<abi, functionName, args, chain, account, chainOverride>
        type wallet = WalletClient<Transport, chain, account>
        return <
          functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        >(parameters: Omit<PartialPick<parameters<functionName, args>, 'chain' | 'account' | 'address'>, 'abi'> & { client?: wallet }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return writeContract((parameters.client || wallet) as wallet, { address, abi, ...parameters } as unknown as parameters<functionName, args>)
        }
      }
      export function createWriteContractBy<
        chain extends Chain | undefined,
        account extends Account | undefined,
        const abi extends Abi | readonly unknown[],
        functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
        chainOverride extends Chain | undefined,
      >(abi: abi, functionName: functionName) {
        type parameters<
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        > = WriteContractParameters<abi, functionName, args, chain, account, chainOverride>
        type wallet = WalletClient<Transport, chain, account>
        return <
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        >(parameters: Omit<PartialPick<parameters<args>, 'chain' | 'account' | 'address'>, 'abi' | 'functionName'>  & { client?: wallet }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return writeContract((parameters.client || wallet) as wallet, { address, abi, functionName, ...parameters } as unknown as parameters<args>)
        }
      }


      export function createGetContract<
        transport extends Transport,
        address extends Address,
        const client extends
        | Client<transport, chain, account>
        | KeyedClient<transport, chain, account>,
        chain extends Chain | undefined = Chain | undefined,
        account extends Account | undefined = Account | undefined,
      >() {
        type parameters<abi extends Abi | readonly unknown[]> = GetContractParameters<transport, chain, account, abi, client, address>
        return <abi extends Abi | readonly unknown[]>(parameters: PartialPick<parameters<abi>, 'client' | 'address'>) => {
          const address = parameters.address || get(chain, \`contracts.\${get(parameters.abi, 'name')}.address\`)
          const clients = (parameters.client || { public: client, wallet: wallet }) as Client<transport, chain, account>
          return getContract({ address, abi: parameters.abi, client: clients })
        }
      }

      export function createGetContractBy<
        transport extends Transport,
        address extends Address,
        const abi extends Abi | readonly unknown[],
        const client extends
        | Client<transport, chain, account>
        | KeyedClient<transport, chain, account>,
        chain extends Chain | undefined = Chain | undefined,
        account extends Account | undefined = Account | undefined,
      >(abi: abi) {
        type parameters = GetContractParameters<transport, chain, account, abi, client, address>
        return (parameters: Partial<Pick<parameters, 'client' | 'address'>>) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          const clients = (parameters.client || { public: client, wallet: wallet }) as Client<transport, chain, account>
          return getContract({ address, abi, client: clients })
        }
      }
    `,
  }] as Output[]
}
