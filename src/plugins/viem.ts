import type { Output, Plugin } from '../config'
import { camelCase, pascalCase } from 'change-case'
import dedent from 'dedent'
import { getBannerContent } from './utils'

export function viem(): Plugin {
  return {
    name: 'viem',
    async run(config) {
      const imports = [
        '/* Autogenerated file. Do not edit manually. */',
        '/* tslint:disable */',
        '/* eslint-disable */',
        dedent`
          import {
            createWatchContractEvent,
            createWatchContractEventBy,
            createGetContract,
            createGetContractBy,
            createReadContract,
            createReadContractBy,
            createWriteContract,
            createWriteContractBy,
            createSimulateContract,
            createSimulateContractBy,
          } from './library'
        `,
        `import { ${Object.keys(config.contracts).map(name => `${camelCase(`  ${name}Abi`)}`).join(', ')} } from './config'`,
        `export { ${Object.keys(config.contracts).map(name => `${camelCase(`  ${name}Abi`)}`).join(', ')} } from './config'`,
        dedent`
          export {
            addresses,
            chain,
            chains,
            client,
            wallet,
            connection,
          } from './config'
        `,
      ]

      const contents: (string | string[])[] = [
        'export const getContract = createGetContract()',
        '',
        Object.keys(config.contracts).map((name) => {
          const camelCaseName = camelCase(name)
          const pascalCaseName = pascalCase(name)
          const watchItems: string[] = []
          const readItems: string[] = []
          const writeItems: string[] = []
          const simulateItems: string[] = []

          const readNames = new Set<string>()
          const writeNames = new Set<string>()
          const watchNames = new Set<string>()

          for (const item of config.contracts[name]) {
            if (item.type === 'function') {
              if (item.stateMutability === 'view' || item.stateMutability === 'pure') {
                if (readNames.has(item.name))
                  continue
                readNames.add(item.name)
                readItems.push(`export const read${pascalCaseName}${pascalCase(item.name)} = createReadContractBy(${camelCaseName}Abi, '${item.name}')`)
              }

              if (item.stateMutability === 'nonpayable' || item.stateMutability === 'payable') {
                if (writeNames.has(item.name))
                  continue
                writeNames.add(item.name)
                writeItems.push(`export const write${pascalCaseName}${pascalCase(item.name)} = createWriteContractBy(${camelCaseName}Abi, '${item.name}')`)
                simulateItems.push(`export const simulate${pascalCaseName}${pascalCase(item.name)} = createSimulateContractBy(${camelCaseName}Abi, '${item.name}')`)
              }
            }
            else if (item.type === 'event') {
              if (watchNames.has(item.name))
                continue
              watchNames.add(item.name)
              watchItems.push(`export const watch${pascalCaseName}${pascalCase(item.name)}Event = createWatchContractEventBy(${camelCaseName}Abi, '${item.name}')`)
            }
          }
          return [
            getBannerContent({ name }),
            `export const get${pascalCaseName} = createGetContractBy(${camelCaseName}Abi)`,
            '',
            `export const watch${pascalCaseName}Event = createWatchContractEvent(${camelCaseName}Abi)`,
            ...watchItems,
            '',
            `export const read${pascalCaseName} = createReadContract(${camelCaseName}Abi)`,
            ...readItems,
            '',
            `export const write${pascalCaseName} = createWriteContract(${camelCaseName}Abi)`,
            ...writeItems,
            '',
            `export const simulate${pascalCaseName} = createSimulateContract(${camelCaseName}Abi)`,
            ...simulateItems,
          ].join('\n')
        }).join('\n\n'),
      ]

      const outputs: Output[] = [
        ...await outputUtils(),
        ...await outputLibrary(),
        {
          id: 'config.ts',
          content: dedent`
            /* Autogenerated file. Do not edit manually. */
            /* tslint:disable */
            /* eslint-disable */
            import { createPublicClient, createWalletClient, custom, http } from "viem"
            import { privateKeyToAccount } from "viem/accounts"
            import type { Account, Chain, PublicClient, Transport, WalletClient } from "viem"
            import { proxy, set } from "./utils"

            export const client = proxy<PublicClient>('client')
            export const wallet = proxy<WalletClient<Transport, Chain, Account>>('wallet')
            export const chain = proxy<typeof chains[keyof typeof chains]>('chain')

            export const chains = ${JSON.stringify(config.chains)} as const

            export const addresses = ${JSON.stringify(config.addresses)} as const

            export const connection = proxy('connection', {
              connect(chain: typeof chains[keyof typeof chains], account?: { type: 'eip-1193' | 'provideKey', value: any }) {
                const client = createPublicClient({ chain, transport: http() })
                this.client.proxy.update(client)
                this.chain.proxy.update(chain)
                if (account?.type === 'eip-1193') {
                  return (async () => {
                    const [address] = await account.value.request({ method: 'eth_requestAccounts' })
                    const wallet = createWalletClient({ chain, transport: custom(account.value), account: address })
                    this.wallet.proxy.update(wallet as WalletClient<Transport, Chain, Account>)
                    if (account.value.chainId !== \`0x\${chain.id.toString(16)}\`) {
                      await wallet.switchChain({ id: chain.id }).catch(error => {
                        if (error.code === 4902)
                          wallet.addChain({ chain }).then(() => wallet.switchChain({ id: chain.id }))
                      })
                    }
                  })()
                }
                if (account?.type === 'provideKey') {
                  const wallet = createWalletClient({ chain, transport: http(), account: privateKeyToAccount(account.value) })
                  this.wallet.proxy.update(wallet)
                }
              },
              update(chain?: typeof chains[keyof typeof chains], client?: PublicClient, wallet?: WalletClient<Transport, Chain, Account>) {
                if (chain) this.chain.proxy.update(chain)
                if (client) this.client.proxy.update(client)
                if (wallet) this.wallet.proxy.update(wallet)
              },
              client,
              wallet,
              chain
            })

            ${Object
              .keys(config.contracts)
              .map(name => `export const ${camelCase(`${name}Abi`)} = set(${JSON.stringify(config.contracts[name])} as const, 'name', '${name}')`)
              .join('\n\n')}
          `,
        },
        {
          id: 'index.ts',
          imports: imports.join('\n'),
          content: contents.flat().join('\n'),
        },
      ]

      return outputs
    },
  }
}

async function outputUtils(): Promise<Output[]> {
  return [{
    id: 'utils.ts',
    content: dedent`
    /* Autogenerated file. Do not edit manually. */
    /* tslint:disable */
    /* eslint-disable */
    export type Proxyed<T extends object> = T & { proxy: { update: (object?: T) => void, resolve: () => T | undefined } }

    export function proxy<T extends object>(name: string, initObject?: T): Proxyed<T> {
      initObject && Reflect.set(initObject, 'proxyUpdated', true)
      let target: any = initObject || { proxyUpdated: false }
      const proxy = new Proxy({} as T, {
        get: (_, p) => {
          if (p === 'proxy') return { update, resolve }
          if (!Reflect.get(target, 'proxyUpdated'))
            throw new Error(\`Proxy not updated. Call \${name}.proxy.update() to update the proxy.\`)
          return typeof target?.[p] === 'function' ? target?.[p].bind(target) : target?.[p]
        },
        set: (_, p, v) => { target[p] = v; return true },
      })
      function update(object?: T): void {
        if (object) { Reflect.set(object, 'proxyUpdated', true); target = object }
        else { target = undefined }
      }
      function resolve(): T | undefined {
        return Reflect.get(target, 'proxyUpdated') ? target : undefined
      }
      return proxy as Proxyed<T>
    }

    export function get(target: any, keys: string): any {
      return keys.split('.').reduce((acc, key) => acc?.[key], target)
    }

    export function set<T extends object>(target: T, property: string, value: any): T {
      Reflect.set(target, property, value)
      return target as T
    }
    `,
  }] as Output[]
}

async function outputLibrary(): Promise<Output[]> {
  return [{
    id: 'library.ts',
    content: dedent`
      /* Autogenerated file. Do not edit manually. */
      /* tslint:disable */
      /* eslint-disable */
      import type {
        Abi,
        Account,
        Address,
        Chain,
        Client,
        ContractEventName,
        ContractFunctionArgs,
        ContractFunctionName,
        GetContractParameters,
        ReadContractParameters,
        SimulateContractParameters,
        PublicClient,
        Transport,
        WalletClient,
        WatchContractEventParameters,
        WriteContractParameters
      } from "viem"
      import { getContract } from 'viem'
      import { readContract, watchContractEvent, writeContract, simulateContract } from "viem/actions"
      import { get } from "./utils";
      import { chain, client, wallet } from "./config";

      export type KeyedClient<
        transport extends Transport = Transport,
        chain extends Chain | undefined = Chain | undefined,
        account extends Account | undefined = Account | undefined,
      > =
        | { public?: Client<transport, chain> | undefined; wallet: Client<transport, chain, account> }
        | { public: Client<transport, chain>; wallet?: Client<transport, chain, account> | undefined }
      export type PartialPick<T, K extends keyof T> = { [P in K]?: T[P] } & Omit<T, K>


      export function createWatchContractEvent<
        chain extends Chain | undefined,
        const abi extends Abi | readonly unknown[],

        strict extends boolean | undefined = undefined,
        transport extends Transport = Transport,
      >(abi: abi) {
        type parameters<
          eventName extends ContractEventName<abi> | undefined = undefined,
        > = WatchContractEventParameters<abi, eventName, strict, transport>
        type client = Client<transport, chain>
        return <
          eventName extends ContractEventName<abi> | undefined = undefined
        >(parameters: Omit<parameters<eventName>, 'abi'> & { client?: client }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return watchContractEvent((parameters.client || client) as client, { abi, address, ...parameters } as parameters)
        }
      }

      export function createWatchContractEventBy<
        chain extends Chain | undefined,
        const abi extends Abi | readonly unknown[],
        eventName extends ContractEventName<abi> | undefined = undefined,
        strict extends boolean | undefined = undefined,
        transport extends Transport = Transport,
      >(abi: abi, eventName: eventName) {
        type parameters = WatchContractEventParameters<abi, eventName, strict, transport>
        type client = Client<transport, chain>
        return (parameters: Omit<parameters, 'abi'> & { client?: client }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return watchContractEvent((parameters.client || client) as client, { abi, address, ...parameters } as parameters)
        }
      }

      export function createReadContract<
        chain extends Chain | undefined,
        const abi extends Abi | readonly unknown[],
        transport extends Transport = Transport,
      >(abi: abi) {
        type client = Client<transport, chain>
        return <
          functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
          const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
        >(parameters: Omit<ReadContractParameters<abi, functionName, args>, 'abi'> & { client?: client }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return readContract((parameters.client || client) as client, { abi, address, ...parameters } as ReadContractParameters<abi, functionName, args>)
        }
      }

      export function createReadContractBy<
        chain extends Chain | undefined,
        const abi extends Abi | readonly unknown[],
        functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
        transport extends Transport = Transport,
      >(abi: abi, functionName: functionName) {
        type client = Client<transport, chain>

        return <
          const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
        >(parameters: Omit<ReadContractParameters<abi, functionName, args>, 'abi' | 'functionName'>  & { client?: client }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return readContract((parameters.client || client) as client, { abi, address, functionName, ...parameters } as ReadContractParameters<abi, functionName, args>)
        }
      }


      export function createWriteContract<
        chain extends Chain | undefined,
        account extends Account | undefined,
        const abi extends Abi | readonly unknown[],
        chainOverride extends Chain | undefined,
      >(abi: abi) {
        type parameters<
          functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        > = WriteContractParameters<abi, functionName, args, chain, account, chainOverride>
        type wallet = WalletClient<Transport, chain, account>
        return <
          functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        >(parameters: Omit<PartialPick<parameters<functionName, args>, 'chain' | 'account' | 'address'>, 'abi'> & { client?: wallet }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return writeContract((parameters.client || wallet) as wallet, { address, abi, ...parameters } as unknown as parameters<functionName, args>)
        }
      }
      export function createWriteContractBy<
        chain extends Chain | undefined,
        account extends Account | undefined,
        const abi extends Abi | readonly unknown[],
        functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
        chainOverride extends Chain | undefined,
      >(abi: abi, functionName: functionName) {
        type parameters<
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        > = WriteContractParameters<abi, functionName, args, chain, account, chainOverride>
        type wallet = WalletClient<Transport, chain, account>
        return <
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        >(parameters: Omit<PartialPick<parameters<args>, 'chain' | 'account' | 'address'>, 'abi' | 'functionName'>  & { client?: wallet }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return writeContract((parameters.client || wallet) as wallet, { address, abi, functionName, ...parameters } as unknown as parameters<args>)
        }
      }

      export function createSimulateContract<
        chain extends Chain | undefined,
        account extends Account | undefined,
        const abi extends Abi | readonly unknown[]
      >(abi: abi) {
        type parameters<
          functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        > = SimulateContractParameters<abi, functionName, args, chain>
        type wallet = WalletClient<Transport, chain, account>
        return <
          functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        >(parameters: Omit<PartialPick<parameters<functionName, args>, 'chain' | 'account' | 'address'>, 'abi'> & { client?: wallet }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return simulateContract((parameters.client || wallet) as wallet, { address, abi, ...parameters } as unknown as parameters<functionName, args>)
        }
      }

      export function createSimulateContractBy<
        chain extends Chain | undefined,
        account extends Account | undefined,
        const abi extends Abi | readonly unknown[],
        functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>
      >(abi: abi, functionName: functionName) {
        type parameters<
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        > = SimulateContractParameters<abi, functionName, args, chain>
        type wallet = WalletClient<Transport, chain, account>
        return <
          args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
        >(parameters: Omit<PartialPick<parameters<args>, 'chain' | 'account' | 'address'>, 'abi' | 'functionName'> & { client?: wallet }) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          return simulateContract((parameters.client || wallet) as wallet, { address, abi, functionName, ...parameters } as unknown as parameters<args>)
        }
      }

      export function createGetContract<
        transport extends Transport,
        address extends Address,
        const client extends
        | Client<transport, chain, account>
        | KeyedClient<transport, chain, account>,
        chain extends Chain | undefined = Chain | undefined,
        account extends Account | undefined = Account | undefined,
      >() {
        type parameters<abi extends Abi | readonly unknown[]> = GetContractParameters<transport, chain, account, abi, client, address>
        return <abi extends Abi | readonly unknown[]>(parameters: PartialPick<parameters<abi>, 'client' | 'address'>) => {
          const address = parameters.address || get(chain, \`contracts.\${get(parameters.abi, 'name')}.address\`)
          const clients = (parameters.client || { public: client, wallet: wallet }) as Client<transport, chain, account>
          return getContract({ address, abi: parameters.abi, client: clients })
        }
      }

      export function createGetContractBy<
        transport extends Transport,
        address extends Address,
        const abi extends Abi | readonly unknown[],
        const client extends
        | Client<transport, chain, account>
        | KeyedClient<transport, chain, account>,
        chain extends Chain | undefined = Chain | undefined,
        account extends Account | undefined = Account | undefined,
      >(abi: abi) {
        type parameters = GetContractParameters<transport, chain, account, abi, client, address>
        return (parameters: Partial<Pick<parameters, 'client' | 'address'>>) => {
          const address = parameters.address || get(chain, \`contracts.\${get(abi, 'name')}.address\`)
          const clients = (parameters.client || { public: client, wallet: wallet }) as Client<transport, chain, account>
          return getContract({ address, abi, client: clients })
        }
      }
    `,
  }] as Output[]
}
