import type { Output, Plugin } from '../config'
import { camelCase } from 'change-case'
import dedent from 'dedent'

export function viem(): Plugin {
  return {
    name: 'ethers',
    async run(config) {
      const imports = [
        '/* Autogenerated file. Do not edit manually. */',
        '/* tslint:disable */',
        '/* eslint-disable */',
        `import { type Abi, type PublicClient, type WalletClient, getContract as getViemContract } from 'viem'`,
        `import { set, get, proxy, type GetContractAtConfig, type GetContractConfig } from './library'`,
      ]

      const content: (string | string[])[] = [
        `export const client = proxy<PublicClient>()`,
        `export const wallet = proxy<WalletClient>()`,
        `export const chain = proxy<typeof chains[keyof typeof chains]>()`,
        '',
        `export const chains = ${JSON.stringify(config.chains)} as const`,
        '',
        `export const addresses = ${JSON.stringify(config.addresses)} as const`,
        '',

        Object.keys(config.contracts).map((name) => {
          return `export const ${camelCase(`${name}Abi`)} = set(${JSON.stringify(config.contracts[name])} as const, 'name', '${name}')`
        }).join('\n'),
        '',
        `export function getContract<Fragment extends Abi>(config: GetContractConfig<Fragment>) {`,
        `  const address = config.address || get(chain, \`contracts.\${get(config.abi, 'name')}.address\`)`,
        `  const clients = (config.client || { public: client, wallet: wallet }) as WalletClient`,
        `  return getViemContract({ address, abi: config.abi, client: clients })`,
        `}`,
        '',
        Object.keys(config.contracts).map((name) => {
          return [
            '/**',
            ` * Wraps __{@link get${name}Contract}__ with \`abi\` set to __{@link ${camelCase(`${name}Abi`)}}__`,
            ' */',
            `export function getContract${name}(config: GetContractAtConfig = {}) {`,
            `  return getContract({ abi: ${camelCase(`${name}Abi`)}, ...config })`,
            `}`,
          ].join('\n')
        }).join('\n\n'),
      ]

      const outputs: Output[] = [
        ...await outputLibrary(),
        {
          id: 'index.ts',
          imports: imports.join('\n'),
          content: content.flat().join('\n'),
        },
      ]

      return outputs
    },
  }
}

async function outputLibrary(): Promise<Output[]> {
  return [{
    id: 'library.ts',
    content: dedent`
      /* Autogenerated file. Do not edit manually. */
      /* tslint:disable */
      /* eslint-disable */
      import { type Abi, type GetContractParameters } from "viem"

      export interface GetContractConfig<Fragment extends Abi> {
        abi: Fragment
        address?: string
        client?: GetContractParameters['client']
      }

      export interface GetContractAtConfig {
        address?: string
        client?: GetContractParameters['client']
      }

      export type Proxyed<T extends object> = T & { proxy: { update: (object?: T) => void, resolve: () => T | undefined } }
      export function proxy<T extends object>(initObject?: T): Proxyed<T> {
        initObject && Reflect.set(initObject, 'proxyUpdated', true)
        let target: any = initObject || { proxyUpdated: false }
        const proxy = new Proxy<any>({}, {
          get: (_, p) => {
            return typeof target?.[p] === 'function'
              ? target?.[p].bind(target)
              : target?.[p]
          },
          set: (_, p, v) => {
            target[p] = v
            return true
          },
        }) as T

        function update(object?: T): void {
          if (!object) {
            target = undefined
            return
          }
          Reflect.set(object, 'proxyUpdated', true)
          target = object
        }

        function resolve(): T | undefined {
          return Reflect.get(target, 'proxyUpdated') ? target : undefined
        }

        Reflect.set(proxy, 'proxy', { update, resolve })

        return proxy as Proxyed<T>
      }

      export function get(target: any, keys: string): any {
        return keys.split('.').reduce((acc, key) => acc?.[key], target)
      }

      export function set<T extends object>(target: T, property: string, value: any): T {
        Reflect.set(target, property, value)
        return target as T
      }
    `,
  }] as Output[]
}
