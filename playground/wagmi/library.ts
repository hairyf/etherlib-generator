/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  Abi,
  Account,
  Address,
  Chain,
  Client,
  ContractEventName,
  ContractFunctionArgs,
  ContractFunctionName,
  GetContractParameters,
  ReadContractParameters,
  Transport,
  WalletClient,
  WatchContractEventParameters,
  WriteContractParameters
} from "viem"
import { getContract } from 'viem'
import { useEffect, useMemo } from 'react'
import { usePublicClient, useWalletClient, useChainId } from 'wagmi'
import { readContract, watchContractEvent, writeContract } from "viem/actions"
import { get } from "./utils";
import { addresses, chain, chains, client, wallet } from "./config";

export type KeyedClient<
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
> =
  | { public?: Client<transport, chain> | undefined; wallet: Client<transport, chain, account> }
  | { public: Client<transport, chain>; wallet?: Client<transport, chain, account> | undefined }
export type PartialPick<T, K extends keyof T> = { [P in K]?: T[P] } & Omit<T, K>


export function createWatchContractEvent<
  chain extends Chain | undefined,
  const abi extends Abi | readonly unknown[],

  strict extends boolean | undefined = undefined,
  transport extends Transport = Transport,
>(abi: abi) {
  type parameters<
    eventName extends ContractEventName<abi> | undefined = undefined,
  > = WatchContractEventParameters<abi, eventName, strict, transport>
  type client = Client<transport, chain>
  return <
    eventName extends ContractEventName<abi> | undefined = undefined
  >(parameters: Omit<parameters<eventName>, 'abi'> & { client?: client }) => {
    const address = parameters.address || get(chain, `contracts.${get(abi, 'name')}.address`)
    return watchContractEvent((parameters.client || client) as client, { abi, address, ...parameters } as parameters)
  }
}

export function createWatchContractEventBy<
  chain extends Chain | undefined,
  const abi extends Abi | readonly unknown[],
  eventName extends ContractEventName<abi> | undefined = undefined,
  strict extends boolean | undefined = undefined,
  transport extends Transport = Transport,
>(abi: abi, eventName: eventName) {
  type parameters = WatchContractEventParameters<abi, eventName, strict, transport>
  type client = Client<transport, chain>
  return (parameters: Omit<parameters, 'abi'> & { client?: client }) => {
    const address = parameters.address || get(chain, `contracts.${get(abi, 'name')}.address`)
    return watchContractEvent((parameters.client || client) as client, { abi, address, ...parameters } as parameters)
  }
}

export function createReadContract<
  chain extends Chain | undefined,
  const abi extends Abi | readonly unknown[],
  transport extends Transport = Transport,
>(abi: abi) {
  type client = Client<transport, chain>
  return <
    functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
    const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
  >(parameters: Omit<ReadContractParameters<abi, functionName, args>, 'abi'> & { client?: client }) => {
    const address = parameters.address || get(chain, `contracts.${get(abi, 'name')}.address`)
    return readContract((parameters.client || client) as client, { abi, address, ...parameters } as ReadContractParameters<abi, functionName, args>)
  }
}

export function createReadContractBy<
  chain extends Chain | undefined,
  const abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
  transport extends Transport = Transport,
>(abi: abi, functionName: functionName) {
  type client = Client<transport, chain>

  return <
    const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
  >(parameters: Omit<ReadContractParameters<abi, functionName, args>, 'abi' | 'functionName'>  & { client?: client }) => {
    const address = parameters.address || get(chain, `contracts.${get(abi, 'name')}.address`)
    return readContract((parameters.client || client) as client, { abi, address, functionName, ...parameters } as ReadContractParameters<abi, functionName, args>)
  }
}


export function createWriteContract<
  chain extends Chain | undefined,
  account extends Account | undefined,
  const abi extends Abi | readonly unknown[],
  chainOverride extends Chain | undefined,
>(abi: abi) {
  type parameters<
    functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
    args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
  > = WriteContractParameters<abi, functionName, args, chain, account, chainOverride>
  type wallet = WalletClient<Transport, chain, account>
  return <
    functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
    args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
  >(parameters: Omit<PartialPick<parameters<functionName, args>, 'chain' | 'account' | 'address'>, 'abi'> & { client?: wallet }) => {
    const address = parameters.address || get(chain, `contracts.${get(abi, 'name')}.address`)
    return writeContract((parameters.client || wallet) as wallet, { address, abi, ...parameters } as unknown as parameters<functionName, args>)
  }
}
export function createWriteContractBy<
  chain extends Chain | undefined,
  account extends Account | undefined,
  const abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  chainOverride extends Chain | undefined,
>(abi: abi, functionName: functionName) {
  type parameters<
    args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
  > = WriteContractParameters<abi, functionName, args, chain, account, chainOverride>
  type wallet = WalletClient<Transport, chain, account>
  return <
    args extends ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>
  >(parameters: Omit<PartialPick<parameters<args>, 'chain' | 'account' | 'address'>, 'abi' | 'functionName'>  & { client?: wallet }) => {
    const address = parameters.address || get(chain, `contracts.${get(abi, 'name')}.address`)
    return writeContract((parameters.client || wallet) as wallet, { address, abi, functionName, ...parameters } as unknown as parameters<args>)
  }
}

export function createGetContract<
  transport extends Transport,
  address extends Address,
  const client extends
  | Client<transport, chain, account>
  | KeyedClient<transport, chain, account>,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
>() {
  type parameters<abi extends Abi | readonly unknown[]> = GetContractParameters<transport, chain, account, abi, client, address>
  return <abi extends Abi | readonly unknown[]>(parameters: PartialPick<parameters<abi>, 'client' | 'address'>) => {
    const address = parameters.address || get(chain, `contracts.${get(parameters.abi, 'name')}.address`)
    const clients = (parameters.client || { public: client, wallet: wallet }) as Client<transport, chain, account>
    return getContract({ address, abi: parameters.abi, client: clients })
  }
}

export function createGetContractBy<
  transport extends Transport,
  address extends Address,
  const abi extends Abi | readonly unknown[],
  const client extends
  | Client<transport, chain, account>
  | KeyedClient<transport, chain, account>,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
>(abi: abi) {
  type parameters = GetContractParameters<transport, chain, account, abi, client, address>
  return (parameters: Partial<Pick<parameters, 'client' | 'address'>>) => {
    const address = parameters.address || get(chain, `contracts.${get(abi, 'name')}.address`)
    const clients = (parameters.client || { public: client, wallet: wallet }) as Client<transport, chain, account>
    return getContract({ address, abi, client: clients })
  }
}


export function createUseContract<
  transport extends Transport,
  address extends Address,
  const client extends
  | Client<transport, chain, account>
  | KeyedClient<transport, chain, account>,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
>() {
  type parameters<abi extends Abi | readonly unknown[]> = GetContractParameters<transport, chain, account, abi, client, address>
  return <abi extends Abi | readonly unknown[]>(parameters: PartialPick<parameters<abi>, 'client' | 'address'>) => {
    const address = parameters.address || get(addresses, `${get(parameters.abi, 'name')}.${useChainId()}`)
    const clients = (parameters.client || { public: usePublicClient(), wallet: useWalletClient() })
    return getContract({ address, abi: parameters.abi, client: clients as Client<transport, chain, account> })
  }
}

export function createUseContractBy<
  transport extends Transport,
  address extends Address,
  const abi extends Abi | readonly unknown[],
  const client extends
  | Client<transport, chain, account>
  | KeyedClient<transport, chain, account>,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
>(abi: abi) {
  type parameters = GetContractParameters<transport, chain, account, abi, client, address>
  return (parameters: Partial<Pick<parameters, 'client' | 'address'>>) => {
    const address = parameters.address || get(addresses, `${get(abi, 'name')}.${useChainId()}`)
    const clients = (parameters.client || { public: usePublicClient(), wallet: useWalletClient() })
    return getContract({ address, abi, client: clients as Client<transport, chain, account> })
  }
}

export function SubscribeWagmiConfig(props: { children?: any }) {
  const chainId = useChainId()
  const walletClient = useWalletClient()
  const publicClient = usePublicClient()
  const findChain = useMemo(() => Object.values(chains).find((chain) => chain.id === chainId), [chainId])
  useEffect(() => { client.proxy.update(publicClient as any) }, [publicClient])
  useEffect(() => { wallet.proxy.update(walletClient as any) }, [walletClient])
  useEffect(() => { chain.proxy.update(findChain) }, [findChain])
  return props.children
}