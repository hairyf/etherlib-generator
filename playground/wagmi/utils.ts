/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type Proxyed<T extends object> = T & { proxy: { update: (object?: T) => void, resolve: () => T | undefined } }

export function proxy<T extends object>(initObject?: T): Proxyed<T> {
  initObject && Reflect.set(initObject, 'proxyUpdated', true)
  let target: any = initObject || { proxyUpdated: false }
  const proxy = new Proxy({} as T, {
    get: (_, p) => typeof target?.[p] === 'function' ? target?.[p].bind(target) : target?.[p],
    set: (_, p, v) => { target[p] = v; return true },
  })
  function update(object?: T): void {
    if (object) { Reflect.set(object, 'proxyUpdated', true); target = object }
    else { target = undefined }
  }
  function resolve(): T | undefined {
    return Reflect.get(target, 'proxyUpdated') ? target : undefined
  }
  Reflect.set(proxy, 'proxy', { update, resolve })
  return proxy as Proxyed<T>
}

export function get(target: any, keys: string): any {
  return keys.split('.').reduce((acc, key) => acc?.[key], target)
}

export function set<T extends object>(target: T, property: string, value: any): T {
  Reflect.set(target, property, value)
  return target as T
}